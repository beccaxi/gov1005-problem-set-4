---
title: "Problem Set 4"
author: "Rebecca Xi"
date: "3/04/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, options(scipen = 999))

library(tidyverse)
library(tidycensus)
library(ggplot2)
library(gt)

# Here I load the data I'll need for the rest of this pset

income <- get_acs(
  geography = "county",
  variables = "B19013_001",
  year = 2018
) 
```

## Question #1: Mad Libs

```{r Mad Libs 1, include=FALSE}

# This function should take a numeric vector (like our column, estimate) and
# calculate the standard deviation of the variable, then adds 1.

# To get the code to run, I added the missing parentheses at the end of return(x
# to make it return(x). As per the Piazza post, I also moved the +1 from inside
# the sd() to outside, since the function is supposed to calculate standard
# deviation first and then add 1. 

sd_plus_one <- function(var, na.rm = TRUE){
  x<- sd(var, na.rm = na.rm) + 1
  return(x)
  }

r1 <- sd_plus_one(var = income$estimate)
```

ML 1) The standard deviation of median income, plus one, is `r r1`.


```{r Mad Libs 2, include=FALSE}

# This function should take a county and state pair and extracts just the state
# name. We can do this easily because the state name is always after a comma and
# space.

# To get the code to run, I added in the missing pipe operator from countystate
# to str_split_fixed

 get_state <- function(countystate){
  countystate %>% 
  str_split_fixed(.,", ", 2) %>% 
  pluck(2) %>% 
  return()
 }

r2 <- get_state("Treasure County, Montana")
```

ML 2) Treasure County, Montana is located in the state of `r r2`.


```{r Mad Libs 3, include=FALSE}

# This function should take the geoid for a given county, grabs the median
# income for the corresponding county, and then add the margin of error to the
# value.

# To get the code to run, I removed the extra closing parentheses from the end
# of pull(). I also changed the argument x in function(x) to geoid, for
# function(geoid), since geoid is the name of the argument we enter later. I
# also fixed the discrepancy between r code chunk and Mad Lib prompt by changing
# the given geoid from "01005" to "01055". 

upper_bound <- function(geoid){
 income %>% 
 filter(GEOID == geoid) %>% 
 mutate(estimate + moe) %>% 
 pull()
}

r3 <- upper_bound(geoid = "01055")
```

ML 3) The upper bound for median income in Etowah County, Alabama (geoid = 
“01055”) is `r r3`.


## Question #2: Mapping

```{r Mapping Setup, include=FALSE}

# Here I called get_acs again to get data specific to California, which is the
# state of interest in this question

california <- get_acs(
  geography = "county",
  variables = "B19013_001",
  state = "CA",
  year = 2018,
  geometry = TRUE
)
```

```{r Mapping, echo=FALSE}
  
# Having created the california dataset in the previous code chunk, here I
# plotted it using geom_sf() and fill = estimate in order to differentiate by
# (estimated) median income. Many of the design elements are taken from the
# Preceptor's textbook chapter on Maps. As a note: I had to make sure to use
# breaks= and labels= in tandem within scale_fill_viridis_c() for it to work.

california %>% 
  ggplot(aes(fill = estimate)) +
  geom_sf() +
  scale_fill_viridis_c(
    option = "plasma",
    direction = -1,
    breaks = c(40000, 60000, 80000, 100000),
    labels = c("40,000", "60,000", "80,000", "100,000")
  ) +
  labs(
    title = "Median Income by County in California",
    caption = "Source: American Communities Survey 2018",
    fill = "Median Income"
  ) +
  theme_void()
```


## Question #3: Publishing to Rpubs

https://rpubs.com/Becca63/pset_4_rpub


## Question #4: Understanding Tufte Reading

Most glaringly obvious is the wasted space on all sides of each slide. The 
header is unnecessarily large and padded too generously, and the font in general
can be downsized to add room for more text. The overly large logo at the bottom 
is an example of pushy branding by LAO and contributes nothing to slide content. 
Bullet points throughout are misused. In many cases, the larger bullet points 
convey no meaningful information and serve only to introduce the sub-bullet 
points that follow; eliminating those header bullet points would provide space 
for more actual content. The numeric content on slide 9 is extremely simplified 
- the entire slide only conveys 8 numbers - and it is not immediately clear that
the sales and use tax and the corporation tax numbers are also percentages, 
since the % sign is foregone. In general, it is difficult to understand the 
graphs and tables without any context. This holds true for the entire slide deck
- it is impossible to glean a solid understanding of what's going on just by 
looking at the slides, since they are standalone and don't convey nearly enough
information. In transforming the slide deck into an 8x11 handout, one should 
create an actual narrative with complete sentences, functional descriptions, 
as many paragraphs as needed to establish context, and transitional sentences as
appropriate. The beginning of the handout should credit the actual curators of 
the content rather than simply "LAO" and provide a table of contents and 
comprehensive topic sentences throughout.


## Question #5: Functions

#### 5A

```{r 5A}

# This function rolls an alphabetical die n times and takes the earliest letter
# in the alphabet. 

# Defining this function was pretty straightforward, given the existence of
# "letters" in R and the ability to call min() to find the "smallest" letter in
# the alphabet

get_letters <- function(n){
  sample(letters, size = n) %>% 
    min()
}

r4 <- get_letters(n = 3)
```

Rolling the alphabetical die 3 times yields `r r4`.


#### 5B

```{r 5B}

# This function calls the get_letters function n times (imagine that "n" is the
# number of people throwing for a certain number of letters). The function calls
# groups of 3 letters.

# The function defined below essentially maps the (singular) result of get_dice
# n times, from 1 to n, in a tibble

# CHECK THIS!!!!

roll_alpha_dice <- function(n){
  map_chr(1:n, ~ get_letters(3))
}
```


#### 5C

```{r 5C}

# Here I make a tibble that stores the results of the 4 TF's playing this game
# 100 times, followed by a gt table showing the first 5 rows.

# The function roll_alpha_dice() already has a "default" of get_letters(3) to
# get 3 letters per player per game, and for the tibble we now set a "default"
# of roll_alpha_dice(4) to account for the 4 players in the game. I specify
# 1:100 to model the game being played 100 times.

#r5 <- tibble(map_chr(1:100, ~ roll_alpha_dice(4)))

# Make a gt table showing the first 5 rows.
# Each row of your gtable should have four letters. Let’s imagine that the first
# letter in each row is the letter that Alyssa rolled. Using the same scenario
# of 100 rolls and 4 tfs rolling 3 dice, use a map_lgl command to create a
# column “vowel”, which tests whether the first letter of each row is a vowel
# (a,e,i,o,u). Report how many times the letter selected was a vowel. For example, we had 28 vowels.

'r6 <- r5 %>% 
  slice(1:5) %>% 
  gt()'
```



#### 5D

```{r 5D}

# This function rolls an alphabetical die n times and takes the earliest letter
# in the alphabet. 

# Defining this function was pretty straightforward, given the existence of
# "letters" in R and the ability to call min() to find the "smallest" letter in
# the alphabet, so to speak

get_dice <- function(n){
  sample(letters, size = n) %>% 
    min()
}

r5 <- get_dice(n = 3)
```

How surprised would you be if for all four tf’s the earliest alphabetical letter they rolled was a vowel? Using a tibble that shows the four tf’s playing the game 10,000 times, calculate the probability that they all roll a vowel.

#### 5E

```{r 5E}

# This function rolls an alphabetical die n times and takes the earliest letter
# in the alphabet. 

# Defining this function was pretty straightforward, given the existence of
# "letters" in R and the ability to call min() to find the "smallest" letter in
# the alphabet, so to speak

get_dice <- function(n){
  sample(letters, size = n) %>% 
    min()
}

r5 <- get_dice(n = 3)
```

Using your functions, make a simple plot mapping the distribution of “first” letters in 1000 rolls of 3 dice. For this example, you can use a single “tf” (n = 1) when you call roll_alpha_dice. Hint: You might want to check out what unnest does.

#### 5F

```{r 5F}

# This function rolls an alphabetical die n times and takes the earliest letter
# in the alphabet. 

# Defining this function was pretty straightforward, given the existence of
# "letters" in R and the ability to call min() to find the "smallest" letter in
# the alphabet, so to speak

get_dice <- function(n){
  sample(letters, size = n) %>% 
    min()
}

r5 <- get_dice(n = 3)
```

Finally, make a plot comparing 5E (selecting the earliest alphabetical letter from 3 dice) with an exercise where the first letter is selected from 5 dice. How does the distribution shift?



#### Colleagues:

* Grace Pan
* Brendan Chapuis

