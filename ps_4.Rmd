---
title: "Problem Set 4"
author: "Rebecca Xi"
date: "3/04/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, options(scipen = 999))

library(tidyverse)
library(tidycensus)
library(ggplot2)
library(gt)

# Here I load the data I'll need for the rest of this pset

income <- get_acs(
  geography = "county",
  variables = "B19013_001",
  year = 2018
) 
```

## Question #1: Mad Libs

```{r Mad Libs 1, include=FALSE}

# This function should take a numeric vector (like our column, estimate) and
# calculate the standard deviation of the variable, then adds 1.

# To get the code to run, I added the missing parentheses at the end of return(x
# to make it return(x). As per the Piazza post, I also moved the +1 from inside
# the sd() to outside, since the function is supposed to calculate standard
# deviation first and then add 1. 

sd_plus_one <- function(var, na.rm = TRUE){
  x<- sd(var, na.rm = na.rm) + 1
  return(x)
  }

r1 <- sd_plus_one(var = income$estimate)
```

ML 1) The standard deviation of median income, plus one, is `r r1`.


```{r Mad Libs 2, include=FALSE}

# This function should take a county and state pair and extracts just the state
# name. We can do this easily because the state name is always after a comma and
# space.

# To get the code to run, I added in the missing pipe operator from countystate
# to str_split_fixed

 get_state <- function(countystate){
  countystate %>% 
  str_split_fixed(.,", ", 2) %>% 
  pluck(2) %>% 
  return()
 }

r2 <- get_state("Treasure County, Montana")
```

ML 2) Treasure County, Montana is located in the state of `r r2`.


```{r Mad Libs 3, include=FALSE}

# This function should take the geoid for a given county, grabs the median
# income for the corresponding county, and then add the margin of error to the
# value.

# To get the code to run, I removed the extra closing parentheses from the end
# of pull(). I also changed the argument x in function(x) to geoid, for
# function(geoid), since geoid is the name of the argument we enter later. I
# also fixed the discrepancy between r code chunk and Mad Lib prompt by changing
# the given geoid from "01005" to "01055". 

upper_bound <- function(geoid){
 income %>% 
 filter(GEOID == geoid) %>% 
 mutate(estimate + moe) %>% 
 pull()
}

r3 <- upper_bound(geoid = "01055")
```

ML 3) The upper bound for median income in Etowah County, Alabama (geoid = 
“01055”) is `r r3`.


## Question #2: Mapping

```{r Mapping Setup, include=FALSE}

# Here I called get_acs again to get data specific to California, which is the
# state of interest in this question

california <- get_acs(
  geography = "county",
  variables = "B19013_001",
  state = "CA",
  year = 2018,
  geometry = TRUE
)
```

```{r Mapping, echo=FALSE}
  
# Having created the california dataset in the previous code chunk, here I
# plotted it using geom_sf() and fill = estimate in order to differentiate by
# (estimated) median income. Many of the design elements are taken from the
# Preceptor's textbook chapter on Maps. As a note: I had to make sure to use
# breaks= and labels= in tandem within scale_fill_viridis_c() for it to work.

california %>% 
  ggplot(aes(fill = estimate)) +
  geom_sf() +
  scale_fill_viridis_c(
    option = "plasma",
    direction = -1,
    breaks = c(40000, 60000, 80000, 100000),
    labels = c("40,000", "60,000", "80,000", "100,000")
  ) +
  labs(
    title = "Median Income by County in California",
    caption = "Source: American Communities Survey 2018",
    fill = "Median Income"
  ) +
  theme_void()
```


## Question #3: Publishing to Rpubs

https://rpubs.com/Becca63/pset_4_rpub


## Question #4: Understanding Tufte Reading

Most glaringly obvious is the wasted space on all sides of each slide. The 
header is unnecessarily large and padded too generously, and the font in general
can be downsized to add room for more text. The overly large logo at the bottom 
is an example of pushy branding by LAO and contributes nothing to slide content. 
Bullet points throughout are misused. In many cases, the larger bullet points 
convey no meaningful information and serve only to introduce the sub-bullet 
points that follow; eliminating those header bullet points would provide space 
for more actual content. The numeric content on slide 9 is extremely simplified 
- the entire slide only conveys 8 numbers - and it is not immediately clear that
the sales and use tax and the corporation tax numbers are also percentages, 
since the % sign is foregone. In general, it is difficult to understand the 
graphs and tables without any context. This holds true for the entire slide deck
- it is impossible to glean a solid understanding of what's going on just by 
looking at the slides, since they are standalone and don't convey nearly enough
information. In transforming the slide deck into an 8x11 handout, one should 
create an actual narrative with complete sentences, functional descriptions, 
as many paragraphs as needed to establish context, and transitional sentences as
appropriate. The beginning of the handout should credit the actual curators of 
the content rather than simply "LAO" and provide a table of contents and 
comprehensive topic sentences throughout.


## Question #5: Functions

#### 5A

```{r 5A, include=FALSE}

# This function rolls an alphabetical die n times and takes the earliest letter
# in the alphabet. 

# Defining this function was pretty straightforward, given the existence of
# "letters" in R and the ability to call min() to find the "smallest" letter in
# the alphabet. I also call stopifnot as described in 6.1.5 in PPBDS.

get_letters <- function(n){
  stopifnot(is.numeric(n)) 
  sample(letters, size = n) %>% 
    min()
}

r4 <- get_letters(n = 3)
```

Rolling the alphabetical die 3 times yields `r r4`.


#### 5B

```{r 5B, include=FALSE}

# This function calls the get_letters function n times (imagine that "n" is the
# number of people throwing for a certain number of letters). The function calls
# groups of 3 letters.

# The function defined below maps the result of get_letters (which is set with
# argument 3) n times in the form of a row vector

roll_alpha_dice <- function(n){
  stopifnot(is.numeric(n)) 
  map_chr(rep(3, n), get_letters)
}
```

See RMarkdown file for function.


#### 5C

```{r 5C, include=FALSE}

# Here I make a tibble that stores the results of the 4 TF's playing this game
# 100 times. The function roll_alpha_dice() already has a "default" of
# get_letters(3) to get 3 letters per player per game, and for the tibble we now
# set a "default" of roll_alpha_dice(4) to account for the 4 players in the
# game. I specify rep(4, 100) to model the game being played 100 times, and I
# expect to see a tibble with 100 rows as a result.

r5 <- tibble(results = map(rep(4, 100), ~ roll_alpha_dice(4)))

# This gt table shows the first 5 rows of r5, each row containing 4 letters
# separated by commas (i.e. not in separate columns)

r6 <- r5 %>% 
  rename("First Five Games" = results) %>% 
  slice(1:5) %>% 
  gt()

# Moving on: here I create a simple function to test whether a letter is a vowel
# or not, for use in the next step within mutate()

isvowel <- function(char){
  char %in% c('a', 'e', 'i', 'o', 'u')
} 

# Here I modify my complete table of 100 games, r5, by using mutate() and
# map_lgl() to create a new column "vowel". In each row, "vowel" records a value
# of either TRUE or FALSE, i.e. the output of my new function isvowel applied to
# the first character of each row.

withvowel <- r5 %>% 
  mutate(vowel = map_lgl(results, ~ isvowel(.[[1]])))

# Here I count how many times Alyssa's letter is a vowel within the 100 games

r7 <- withvowel %>% 
  filter(vowel == TRUE) %>% 
  count()
```

`r r6`

In 100 games, Alyssa rolls `r r7` vowels.


#### 5D

```{r 5D, include=FALSE}

# How surprised would you be if for all four tf’s the earliest alphabetical
# letter they rolled was a vowel? Using a tibble that shows the four tf’s
# playing the game 10,000 times, calculate the probability that they all roll a
# vowel.

# 



```


#### 5E

```{r 5E}

# Using your functions, make a simple plot mapping the distribution of “first”
# letters in 1000 rolls of 3 dice. For this example, you can use a single “tf”
# (n = 1) when you call roll_alpha_dice. Hint: You might want to check out what
# unnest does.

#


```


#### 5F

```{r 5F}

# Finally, make a plot comparing 5E (selecting the earliest alphabetical letter
# from 3 dice) with an exercise where the first letter is selected from 5 dice.
# How does the distribution shift?

#


```




#### Colleagues:

* Grace Pan
* Brendan Chapuis
* Michael Chen
* Rachel Phan
* Brian Kim
* Hudson Miller

